{"head":{"layout":"Post","comments":true,"date":"2018-01-02","title":"Flow avanc√© - Seconde partie: les types opaques","tags":["javascript","flow","type"],"authors":["zoontek"],"description":"Vous avez dig√©r√© le premier article, peut-√™tre m√™me d√©but√© avec flow depuis, mais vous mourez d'envie de d√©couvrir ce que vous pouvez faire‚Ä¶"},"body":"<p>Vous avez dig√©r√© le premier article, peut-√™tre m√™me d√©but√© avec <a href=\"https://flow.org/\">flow</a> depuis, mais vous mourez d'envie de d√©couvrir ce que vous pouvez faire de plus avec votre nouvel outil pr√©f√©r√©¬†? Tant mieux, puisque nous sommes l√† pour parler d'une fonctionnalit√© assez avanc√©e, apparue avec la version 0.51 et, √† l'heure o√π j'√©cris ces lignes, indisponible dans TypeScript: les types opaques.</p>\n<p>Si vous n'avez pas install√© flow au sein de votre projet, je vous renvoie au <a href=\"/fr/articles/js/flow/advanced-part-1/\">premier article</a> qui vous expliquera tr√®s bien comment faire.</p>\n<h2 id=\"transparence-de-types\"><a href=\"#transparence-de-types\" class=\"phenomic-HeadingAnchor\">#</a>Transparence de types</h2>\n<p>Si on parle de types opaques, c'est bien parce que les types transparents existent. D'ailleurs par d√©faut, tout alias de type d√©fini l'est. Mais que sont-ils¬†? Simple: ce sont des types compatibles entre eux et donc interchangeables.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\ntype FirstName = string;\ntype LastName = string;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">yellFirstName</span>(<span class=\"hljs-params\">firstName: FirstName</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(firstName.toUpperCase());\n}\n\n<span class=\"hljs-keyword\">const</span> name: LastName = <span class=\"hljs-string\">\"Acthernoene\"</span>;\nyellFirstName(name);</code></pre>\n<p>Dans cet exemple, les types <code>FirstName</code> et <code>LastName</code> √©tant tout deux des alias de <code>string</code>, on peut sans probl√®me utiliser la variable <code>name</code> de type <code>LastName</code> l√† o√π la function <code>yellFirstName</code> attend un param√®tre de type <code>FirstName</code>. Pas cool.</p>\n<h2 id=\"rendons-tout-cela-opaque\"><a href=\"#rendons-tout-cela-opaque\" class=\"phenomic-HeadingAnchor\">#</a>Rendons tout cela opaque</h2>\n<p>Nous allons donc modifier l'exemple pr√©c√©dent et‚Ä¶</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\nopaque type FirstName = string;\nopaque type LastName = string;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">yellFirstName</span>(<span class=\"hljs-params\">firstName: FirstName</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(firstName.toUpperCase());\n}\n\n<span class=\"hljs-keyword\">const</span> name: LastName = <span class=\"hljs-string\">\"Acthernoene\"</span>;\nyellFirstName(name);</code></pre>\n<p>‚Ä¶toujours pas d'erreur¬†? Du calme, c'est normal. Les types <code>FirstName</code> et <code>LastName</code> √©tant accessibles car dans le m√™me module JS, flow sait que ceux-ci sont des alias de type <code>string</code>. Modifions l'exemple et cr√©ons un deuxi√®me module.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-comment\">// module.js</span>\n\nopaque type FirstName = string;\nopaque type LastName = string;\n\ntype User = {\n  <span class=\"hljs-attr\">firstName</span>: FirstName,\n  <span class=\"hljs-attr\">lastName</span>: LastName\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createUser</span>(<span class=\"hljs-params\">firstName: string, lastName: string</span>): <span class=\"hljs-title\">User</span> </span>{\n  <span class=\"hljs-keyword\">return</span> { firstName, lastName };\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">yellFirstName</span>(<span class=\"hljs-params\">firstName: FirstName</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(firstName.toUpperCase());\n}</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-comment\">// usage.js</span>\n\n<span class=\"hljs-keyword\">import</span> { createUser, yellFirstName } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./module\"</span>;\n\nyellFirstName(<span class=\"hljs-string\">\"Mathieu\"</span>); <span class=\"hljs-comment\">// ‚ö†Ô∏è Erreur: \"string. Ce type est incompatible avec le type de param√®tre attendu FirstName\"</span>\n\n<span class=\"hljs-keyword\">const</span> user = createUser(<span class=\"hljs-string\">\"Acthernoene\"</span>, <span class=\"hljs-string\">\"Mathieu\"</span>);\nyellFirstName(user.firstName); <span class=\"hljs-comment\">// Pas d'erreur</span></code></pre>\n<p>On voit ici qu'il n'est en fait possible d'utiliser le type <code>FirstName</code> qu'apr√®s son assignation au sein du module o√π celui-ci est d√©fini. Un autre exemple: si l'on venait √† rendre le type <code>User</code> opaque, alors nous ne pourrions pas acc√©der √† <code>user.firstName</code>, la propri√©t√© √©tant inaccessible autrement que par une fonction qui manipulera le type <code>User</code>.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-comment\">// module.js</span>\n\nopaque type FirstName = string;\nopaque type LastName = string;\n\nopaque type User = {\n  <span class=\"hljs-attr\">firstName</span>: FirstName,\n  <span class=\"hljs-attr\">lastName</span>: LastName\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createUser</span>(<span class=\"hljs-params\">firstName: string, lastName: string</span>): <span class=\"hljs-title\">User</span> </span>{\n  <span class=\"hljs-keyword\">return</span> { firstName, lastName };\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">yellFirstName</span>(<span class=\"hljs-params\">firstName: FirstName</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(firstName.toUpperCase());\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">yellUserFirstName</span>(<span class=\"hljs-params\">user: User</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(user.firstName.toUpperCase());\n}</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-comment\">// usage.js</span>\n\n<span class=\"hljs-keyword\">import</span> { createUser, yellFirstName, yellUserFirstName } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./module\"</span>;\n\n<span class=\"hljs-keyword\">const</span> user = createUser(<span class=\"hljs-string\">\"Acthernoene\"</span>, <span class=\"hljs-string\">\"Mathieu\"</span>);\nyellFirstName(user.firstName); <span class=\"hljs-comment\">// ‚ö†Ô∏è Erreur: \"Propri√©t√© `firstName`. La propri√©t√© n'est pas accessible sur le type User\"</span>\nyellUserFirstName(user); <span class=\"hljs-comment\">// Pas d'erreur</span></code></pre>\n<h2 id=\"tu-naurais-pas-un-exemple-plus-concret-\"><a href=\"#tu-naurais-pas-un-exemple-plus-concret-\" class=\"phenomic-HeadingAnchor\">#</a>Tu n'aurais pas un exemple plus concret¬†?</h2>\n<p>Bien s√ªr que si¬†! Nous pouvons utiliser les types opaques pour impl√©menter un type <code>UUID</code> tr√®s basique:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-comment\">// uuid.js</span>\n\n<span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">import</span> uuidv4 <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"uuid/v4\"</span>; <span class=\"hljs-comment\">// On installe 2 packages</span>\n<span class=\"hljs-keyword\">import</span> validator <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"validator\"</span>;\n\n<span class=\"hljs-keyword\">export</span> opaque type UUID = string;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">create</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title\">UUID</span> </span>{\n  <span class=\"hljs-keyword\">return</span> uuidv4();\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">check</span>(<span class=\"hljs-params\">uuid: UUID</span>): <span class=\"hljs-title\">boolean</span> </span>{\n  <span class=\"hljs-keyword\">return</span> validator.isUUID(uuid);\n}</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-comment\">// usage.js</span>\n\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> UUID <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./uuid\"</span>;\n\nUUID.check(<span class=\"hljs-string\">\"a duck\"</span>); <span class=\"hljs-comment\">// ‚ö†Ô∏è Erreur: \"string. Ce type est incompatible avec le type de param√®tre attendu UUID\"</span>\nUUID.check(<span class=\"hljs-string\">\"df7cca36-3d7a-40f4-8f06-ae03cc22f045\"</span>); <span class=\"hljs-comment\">// ‚ö†Ô∏è Erreur: \"string. Ce type est incompatible avec le type de param√®tre attendu UUID\"</span>\n\n<span class=\"hljs-keyword\">const</span> uuid = UUID.create();\nUUID.check(uuid); <span class=\"hljs-comment\">// Pas d'erreur</span>\n\nuuid.toUpperCase(); <span class=\"hljs-comment\">// ‚ö†Ô∏è Erreur: \"Appel de m√©thode `toUpperCase`. La m√©thode ne peut pas √™tre appel√©e sur un type UUID\"</span></code></pre>\n<h1 id=\"cest-tout-de-m√™me-assez-restrictifje-voudrais-ne-pas-devoir-tout-r√©impl√©menter\"><a href=\"#cest-tout-de-m%C3%AAme-assez-restrictifje-voudrais-ne-pas-devoir-tout-r%C3%A9impl%C3%A9menter\" class=\"phenomic-HeadingAnchor\">#</a>C'est tout de m√™me assez restrictif‚Ä¶je voudrais ne pas devoir tout r√©impl√©menter</h1>\n<p>Ne vous inqui√©tez pas, les d√©veloppeurs √† l'origine de flow ont tout pr√©vu et pour rem√©dier √† cela il existe ce qu'on appelle le sous-typage (ou <em>SubTyping</em> dans la langue de Shakespeare). Ainsi, nous allons dire √† flow que chaque <code>UUID</code> est un <code>string</code> mais que la r√©ciproque ce sera pas vraie pour autant.</p>\n<p>Reprenons l'exemple pr√©c√©dent.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">import</span> uuidv4 <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"uuid/v4\"</span>;\n<span class=\"hljs-keyword\">import</span> validator <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"validator\"</span>;\n\n<span class=\"hljs-keyword\">export</span> opaque type UUID: string = string; <span class=\"hljs-comment\">// Seul cette ligne change, on y ajoute un sous-type string</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">create</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title\">UUID</span> </span>{\n  <span class=\"hljs-keyword\">return</span> uuidv4();\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">check</span>(<span class=\"hljs-params\">uuid: UUID</span>): <span class=\"hljs-title\">boolean</span> </span>{\n  <span class=\"hljs-keyword\">return</span> validator.isUUID(uuid);\n}</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-comment\">// usage.js</span>\n\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> UUID <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./uuid\"</span>;\n\n<span class=\"hljs-keyword\">const</span> uuid = UUID.create();\nUUID.check(uuid); <span class=\"hljs-comment\">// Pas d'erreur</span>\n\nuuid.toUpperCase(); <span class=\"hljs-comment\">// Pas d'erreur: m√™me si uuid est un UUID, il est utilisable comme un type string</span></code></pre>\n<h2 id=\"que-retenir-de-tout-√ßa-\"><a href=\"#que-retenir-de-tout-%C3%A7a-\" class=\"phenomic-HeadingAnchor\">#</a>Que retenir de tout √ßa¬†?</h2>\n<p>Comme on a pu le voir, les types opaques √©l√®vent clairement le niveau du type-game dans le milieu du JavaScript. Forc√©ment utiles pour imposer l'utilisation de fonctions pour cr√©er / manipuler certaines donn√©es, ils s'av√©reront assez vite indispensables pour structurer davantage votre JS et am√©liorer sa maintenabilit√©.</p>\n<p>Je vous encourage d'ailleurs √† vous en servir quasiment partout (√ßa sera assez chiant au d√©but, mais vous me remercierez plus tard)¬†!</p>\n<p>La bise, et rendez-vous pour une troisi√®me partie üòò</p>\n","rawBody":"\nVous avez dig√©r√© le premier article, peut-√™tre m√™me d√©but√© avec [flow](https://flow.org/) depuis, mais vous mourez d'envie de d√©couvrir ce que vous pouvez faire de plus avec votre nouvel outil pr√©f√©r√©¬†? Tant mieux, puisque nous sommes l√† pour parler d'une fonctionnalit√© assez avanc√©e, apparue avec la version 0.51 et, √† l'heure o√π j'√©cris ces lignes, indisponible dans TypeScript: les types opaques.\n\nSi vous n'avez pas install√© flow au sein de votre projet, je vous renvoie au [premier article](/fr/articles/js/flow/advanced-part-1/) qui vous expliquera tr√®s bien comment faire.\n\n## Transparence de types\n\nSi on parle de types opaques, c'est bien parce que les types transparents existent. D'ailleurs par d√©faut, tout alias de type d√©fini l'est. Mais que sont-ils¬†? Simple: ce sont des types compatibles entre eux et donc interchangeables.\n\n```js\n// @flow\n\ntype FirstName = string;\ntype LastName = string;\n\nfunction yellFirstName(firstName: FirstName) {\n  console.log(firstName.toUpperCase());\n}\n\nconst name: LastName = \"Acthernoene\";\nyellFirstName(name);\n```\n\nDans cet exemple, les types `FirstName` et `LastName` √©tant tout deux des alias de `string`, on peut sans probl√®me utiliser la variable `name` de type `LastName` l√† o√π la function `yellFirstName` attend un param√®tre de type `FirstName`. Pas cool.\n\n## Rendons tout cela opaque\n\nNous allons donc modifier l'exemple pr√©c√©dent et‚Ä¶\n\n```js\n// @flow\n\nopaque type FirstName = string;\nopaque type LastName = string;\n\nfunction yellFirstName(firstName: FirstName) {\n  console.log(firstName.toUpperCase());\n}\n\nconst name: LastName = \"Acthernoene\";\nyellFirstName(name);\n```\n\n‚Ä¶toujours pas d'erreur¬†? Du calme, c'est normal. Les types `FirstName` et `LastName` √©tant accessibles car dans le m√™me module JS, flow sait que ceux-ci sont des alias de type `string`. Modifions l'exemple et cr√©ons un deuxi√®me module.\n\n```js\n// @flow\n// module.js\n\nopaque type FirstName = string;\nopaque type LastName = string;\n\ntype User = {\n  firstName: FirstName,\n  lastName: LastName\n};\n\nexport function createUser(firstName: string, lastName: string): User {\n  return { firstName, lastName };\n}\n\nexport function yellFirstName(firstName: FirstName) {\n  console.log(firstName.toUpperCase());\n}\n```\n\n```js\n// @flow\n// usage.js\n\nimport { createUser, yellFirstName } from \"./module\";\n\nyellFirstName(\"Mathieu\"); // ‚ö†Ô∏è Erreur: \"string. Ce type est incompatible avec le type de param√®tre attendu FirstName\"\n\nconst user = createUser(\"Acthernoene\", \"Mathieu\");\nyellFirstName(user.firstName); // Pas d'erreur\n```\n\nOn voit ici qu'il n'est en fait possible d'utiliser le type `FirstName` qu'apr√®s son assignation au sein du module o√π celui-ci est d√©fini. Un autre exemple: si l'on venait √† rendre le type `User` opaque, alors nous ne pourrions pas acc√©der √† `user.firstName`, la propri√©t√© √©tant inaccessible autrement que par une fonction qui manipulera le type `User`.\n\n```js\n// @flow\n// module.js\n\nopaque type FirstName = string;\nopaque type LastName = string;\n\nopaque type User = {\n  firstName: FirstName,\n  lastName: LastName\n};\n\nexport function createUser(firstName: string, lastName: string): User {\n  return { firstName, lastName };\n}\n\nexport function yellFirstName(firstName: FirstName) {\n  console.log(firstName.toUpperCase());\n}\n\nexport function yellUserFirstName(user: User) {\n  console.log(user.firstName.toUpperCase());\n}\n```\n\n```js\n// @flow\n// usage.js\n\nimport { createUser, yellFirstName, yellUserFirstName } from \"./module\";\n\nconst user = createUser(\"Acthernoene\", \"Mathieu\");\nyellFirstName(user.firstName); // ‚ö†Ô∏è Erreur: \"Propri√©t√© `firstName`. La propri√©t√© n'est pas accessible sur le type User\"\nyellUserFirstName(user); // Pas d'erreur\n```\n\n## Tu n'aurais pas un exemple plus concret¬†?\n\nBien s√ªr que si¬†! Nous pouvons utiliser les types opaques pour impl√©menter un type `UUID` tr√®s basique:\n\n```js\n// @flow\n// uuid.js\n\n// @flow\n\nimport uuidv4 from \"uuid/v4\"; // On installe 2 packages\nimport validator from \"validator\";\n\nexport opaque type UUID = string;\n\nexport function create(): UUID {\n  return uuidv4();\n}\n\nexport function check(uuid: UUID): boolean {\n  return validator.isUUID(uuid);\n}\n```\n\n```js\n// @flow\n// usage.js\n\nimport * as UUID from \"./uuid\";\n\nUUID.check(\"a duck\"); // ‚ö†Ô∏è Erreur: \"string. Ce type est incompatible avec le type de param√®tre attendu UUID\"\nUUID.check(\"df7cca36-3d7a-40f4-8f06-ae03cc22f045\"); // ‚ö†Ô∏è Erreur: \"string. Ce type est incompatible avec le type de param√®tre attendu UUID\"\n\nconst uuid = UUID.create();\nUUID.check(uuid); // Pas d'erreur\n\nuuid.toUpperCase(); // ‚ö†Ô∏è Erreur: \"Appel de m√©thode `toUpperCase`. La m√©thode ne peut pas √™tre appel√©e sur un type UUID\"\n```\n\n# C'est tout de m√™me assez restrictif‚Ä¶je voudrais ne pas devoir tout r√©impl√©menter\n\nNe vous inqui√©tez pas, les d√©veloppeurs √† l'origine de flow ont tout pr√©vu et pour rem√©dier √† cela il existe ce qu'on appelle le sous-typage (ou _SubTyping_ dans la langue de Shakespeare). Ainsi, nous allons dire √† flow que chaque `UUID` est un `string` mais que la r√©ciproque ce sera pas vraie pour autant.\n\nReprenons l'exemple pr√©c√©dent.\n\n```js\n// @flow\n\nimport uuidv4 from \"uuid/v4\";\nimport validator from \"validator\";\n\nexport opaque type UUID: string = string; // Seul cette ligne change, on y ajoute un sous-type string\n\nexport function create(): UUID {\n  return uuidv4();\n}\n\nexport function check(uuid: UUID): boolean {\n  return validator.isUUID(uuid);\n}\n```\n\n```js\n// @flow\n// usage.js\n\nimport * as UUID from \"./uuid\";\n\nconst uuid = UUID.create();\nUUID.check(uuid); // Pas d'erreur\n\nuuid.toUpperCase(); // Pas d'erreur: m√™me si uuid est un UUID, il est utilisable comme un type string\n```\n\n## Que retenir de tout √ßa¬†?\n\nComme on a pu le voir, les types opaques √©l√®vent clairement le niveau du type-game dans le milieu du JavaScript. Forc√©ment utiles pour imposer l'utilisation de fonctions pour cr√©er / manipuler certaines donn√©es, ils s'av√©reront assez vite indispensables pour structurer davantage votre JS et am√©liorer sa maintenabilit√©.\n\nJe vous encourage d'ailleurs √† vous en servir quasiment partout (√ßa sera assez chiant au d√©but, mais vous me remercierez plus tard)¬†!\n\nLa bise, et rendez-vous pour une troisi√®me partie üòò\n","__filename":"fr/articles/js/flow/advanced-part-2.md","__url":"/fr/articles/js/flow/advanced-part-2/","__resourceUrl":"/fr/articles/js/flow/advanced-part-2/index.html","__dataUrl":"/fr/articles/js/flow/advanced-part-2/index.html.e402a3436b617a7c3aaf1acbaef8f668.json"}