{"head":{"layout":"Post","comments":true,"date":"2017-10-26","title":"Swift - la fonction: une closure particuli√®re","tags":["swift","function","closure"],"authors":["leolelego"],"reviewers":["bloodyowl","MoOx"],"header":{"image":"swift.jpg","linearGradient":"0deg, rgba(249,82,51, .9), rgba(252, 136, 63, .7)"},"description":"Swift est un langage simple pour les d√©butants, tout en offrant de grandes possibilit√©es aux d√©veloppeurs exp√©riment√©s. Les fonctions Swift‚Ä¶"},"body":"<p><strong>Swift</strong> est un langage simple pour les d√©butants, tout en offrant de grandes possibilit√©es aux d√©veloppeurs exp√©riment√©s. Les <em>fonctions</em> Swift sont un bon exemple de cette fa√ßon d‚Äôavoir pens√© le langage.</p>\n<h2 id=\"les-fonctions\"><a href=\"#les-fonctions\" class=\"phenomic-HeadingAnchor\">#</a>Les fonctions</h2>\n<h3 id=\"d√©claration-simple\"><a href=\"#d%C3%A9claration-simple\" class=\"phenomic-HeadingAnchor\">#</a>D√©claration simple</h3>\n<p>La d√©claration et l‚Äôutilisation de <em>fonctions</em> est simple. On commence avec le mot cl√© <code>func</code> suivi du <em>nom</em>, puis des <em>param√®tres</em> entre parenth√®ses (a.k.a. <code>input</code>) :</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(name:String, age:UInt)</span></span>{\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello <span class=\"hljs-subst\">\\(name)</span>, you are <span class=\"hljs-subst\">\\(age)</span>\"</span>)\n}</code></pre>\n<p>L‚Äôappel se fait aussi simplement que √ßa : <code>sayHello(name:\"Bob\", age: 32)</code>. Le mot cl√© <code>_</code> permet d'enlever le label du param√®tre dans l'appel si besoin :</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-comment\">// Declaration</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(name:String,<span class=\"hljs-number\">_</span> age:UInt)</span></span>{\n <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello <span class=\"hljs-subst\">\\(name)</span>, you are <span class=\"hljs-subst\">\\(age)</span>\"</span>)\n}\n<span class=\"hljs-comment\">// Appel</span>\nsayHello(name:<span class=\"hljs-string\">\"Bob\"</span>, <span class=\"hljs-number\">32</span>)</code></pre>\n<p>Mais vous perdrez en clart√© de code suivant les cas. Par exemple, avec <code>min(3,6)</code> on voit tout de suite ce que fait la fonction. Alors que <code>sayHelloTo(\"Bob\", 32)</code>, le <code>32</code> pourrait √™tre beaucoup de choses.</p>\n<blockquote>\n<p>Les param√®tres sont obligatoirement typ√©s, mais peuvent √™tre optionnels (en autorisant la valeur nil) avec la notation ? (e.g. Int?, String?).</p>\n</blockquote>\n<p>Vous pouvez aussi d√©finir des valeurs par d√©fauts pour les param√®tres :</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-comment\">// Declaration</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(name:String, <span class=\"hljs-number\">_</span> age:UInt? = <span class=\"hljs-literal\">nil</span>)</span></span>{\n    <span class=\"hljs-keyword\">if</span> age == <span class=\"hljs-literal\">nil</span> {\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello <span class=\"hljs-subst\">\\(name)</span>\"</span>)\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello <span class=\"hljs-subst\">\\(name)</span>, you are <span class=\"hljs-subst\">\\(age!)</span>\"</span>) <span class=\"hljs-comment\">//! permet de pas afficher Optinal(value)</span>\n    }\n}\n<span class=\"hljs-comment\">// Appel</span>\nsayHello(name:<span class=\"hljs-string\">\"Bob\"</span>) <span class=\"hljs-comment\">// -> Hello Bob</span>\nsayHello(name:<span class=\"hljs-string\">\"Bob\"</span>, <span class=\"hljs-number\">32</span>) <span class=\"hljs-comment\">// ->  Hello Bob, you are 32</span></code></pre>\n<p>La plupart du temps nos fonctions servent √† nous retourner des informations. Pour cela on utilise <code>-></code> en signe de retour suivi du type de la valeur retourn√©e.</p>\n<pre><code>func formatHelloSentence(name:String, age:UInt? = nil) -> String {\n    if age == nil {\n        return \"Hello \\(name)\"\n    } else {\n        return \"Hello \\(name), you are \\(age)\"\n    }\n}\n// Appel\nlet helloSentence = formatHelloSentence(name:\"Bob\", age: 32)\n</code></pre>\n<h3 id=\"retours-multiples-ou-tuples\"><a href=\"#retours-multiples-ou-tuples\" class=\"phenomic-HeadingAnchor\">#</a>Retours multiples ou Tuples</h3>\n<p>Apple n‚Äôest pas connu pour sa g√©n√©rosit√©, mais dans Swift ils en ont fait autrement <code>:troll:</code> : on peut retourner plusieurs valeurs avec une seule fonction. Pour cela on utilise un <code>Tuple</code> : un collection de variables ordonn√©es.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">hardFunction</span><span class=\"hljs-params\">(fInputs:[Float])</span></span>->(<span class=\"hljs-type\">Int</span>,<span class=\"hljs-type\">Int</span>,<span class=\"hljs-type\">Float</span>,<span class=\"hljs-type\">String</span>) {    \n    <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">var</span> f : <span class=\"hljs-type\">Float</span> = <span class=\"hljs-number\">0.0</span>\n    <span class=\"hljs-keyword\">var</span> str = <span class=\"hljs-string\">\"\"</span>\n    <span class=\"hljs-comment\">//...</span>\n    <span class=\"hljs-keyword\">return</span> (a,b,f,str)\n}</code></pre>\n<p>Ici cette fonction prend en param√®tres un tableau de <code>Float</code> et retourne un <em>Tuple</em> compos√© de deux <code>Int</code>, un <code>Float</code> et un <code>String</code> dans cet ordre. Vous pouvez alors utiliser le <em>Tuple</em> comme une structure en utilisant l‚Äôindex des √©l√©ments du <em>Tuple</em> comme nom de variable (ex: <code>0</code>pour le premier <code>Int</code>, <code>3</code> pour le <code>String</code>).</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">let</span> myTuple = hardFunction([<span class=\"hljs-number\">2.4</span>,<span class=\"hljs-number\">2.6</span>,<span class=\"hljs-number\">1.8</span>])\n<span class=\"hljs-keyword\">let</span> myTupleString = myTuple.<span class=\"hljs-number\">3</span></code></pre>\n<p>Mais ceci reste assez confus, alors on peut nommer les √©l√©ments.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">hardFunction</span><span class=\"hljs-params\">(fInputs:[Float])</span></span>->(valSup:<span class=\"hljs-type\">Int</span>,\n        valMax:<span class=\"hljs-type\">Int</span>,\n        average:<span class=\"hljs-type\">Float</span>,\n        errorString:<span class=\"hljs-type\">String</span>) {\n    <span class=\"hljs-comment\">//...</span>\n}\n\n<span class=\"hljs-comment\">//utilisation</span>\n<span class=\"hljs-keyword\">let</span> myTuple = hardFunction([<span class=\"hljs-number\">2.4</span>,<span class=\"hljs-number\">2.6</span>,<span class=\"hljs-number\">1.8</span>])\n<span class=\"hljs-keyword\">let</span> myTupleString = myTuple.errorString <span class=\"hljs-comment\">// myTuple.3 marche encore</span></code></pre>\n<p>L'ex√©cution du code permettant d'avoir les valeurs <em>Tuple</em> n'est effectu√©e qu'√† la demande de ces valeurs. Dans l'exemple ci-dessus, le code de <code>hardFunction</code> ne sera appel√© qu'√† la derni√®re ligne, car c'est l√† qu'on a besoin de <code>errorString</code>, pas avant.</p>\n<p> Et la notion de <em>Closure</em> fait son entr√©e!</p>\n<h2 id=\"la-closure-la-variable-fonction\"><a href=\"#la-closure-la-variable-fonction\" class=\"phenomic-HeadingAnchor\">#</a>La closure: la variable-fonction</h2>\n<h3 id=\"qu√©saco\"><a href=\"#qu%C3%A9saco\" class=\"phenomic-HeadingAnchor\">#</a>Qu√©saco</h3>\n<p><strong>Une <em>closure</em> est une partie de code, avec param√®tres et sorties, qui peut √™tre encapsul√© dans une variable, et ex√©cut√©e √† la demande</strong>. Si vous d√©veloppez en C++ ou Objective-C vous connaissez peut-√™tre d√©j√† les <em>blocks</em> et en Java ou C# les <em>lambdas</em> qui sont des <em>features</em> tr√®s (tr√®s) proches.</p>\n<h3 id=\"d√©claration\"><a href=\"#d%C3%A9claration\" class=\"phenomic-HeadingAnchor\">#</a>D√©claration</h3>\n<p>Une <em>closure</em>  se d√©clare gr√¢ce au <code>{}</code> et peut √™tre appel√©e (ex√©cut√©e) gr√¢ce aux parenth√®ses :</p>\n<pre><code class=\"hljs language-swift\"> <span class=\"hljs-keyword\">let</span> helloClosure = {\n     <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"hello, I‚Äôm a closure\"</span>)\n }\n\n helloClosure() <span class=\"hljs-comment\">// Le code est ex√©cut√© ici</span></code></pre>\n<p>√áa vous rappelle rien ? L‚Äôappel d‚Äôune <em>fonction</em> ! En r√©alit√©, la <em>fonction</em> est une <em>closure</em> particuli√®re associ√© √† un contexte (Object, environnement, Bundle...) pour r√©aliser des optimisations et une meilleur compr√©hension du code.</p>\n<blockquote>\n<p>Pour une <em>closure</em> \"√† l‚Äôair libre\", on dit d‚Äôelle, qu‚Äôelle est <em>Self Contained</em> alors qu‚Äôune fonction est contenue par un contexte (<code>class</code> par exemple)</p>\n</blockquote>\n<p>Comme les fonctions, les <em>closures</em>  ont des param√®tres d‚Äôentr√©e et de retour:  </p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">let</span> complexClosure = {(name:<span class=\"hljs-type\">String</span>, age:<span class=\"hljs-type\">Float</span>) -> <span class=\"hljs-type\">Bool</span> <span class=\"hljs-keyword\">in</span>\n    <span class=\"hljs-comment\">// Code</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n}\n<span class=\"hljs-keyword\">let</span> success = complexClosure(<span class=\"hljs-string\">\"Louis\"</span>,<span class=\"hljs-number\">32</span>)\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Louis has <span class=\"hljs-subst\">\\(success)</span>\"</span>)</code></pre>\n<p>Ainsi, les valeurs dans la premi√®re partie apr√®s la <code>{</code> sont les param√®tres d‚Äôentr√©es et apr√®s la <code>-></code> ce sont les param√®tres de sortie. Le code √† ex√©cuter est apr√®s le <code>in</code>.</p>\n<blockquote>\n<p>Comme vous avez d√ª le remarquer, les <em>closures</em> n‚Äôont pas de param√®tres nominatif. IL faut passer les param√®tres d'entr√©e dans l'ordre de la d√©claration.</p>\n</blockquote>\n<h3 id=\"closure-et-type\"><a href=\"#closure-et-type\" class=\"phenomic-HeadingAnchor\">#</a>Closure et Type</h3>\n<p>Toute variable est typ√©e en <em>Swift</em>, implicitement ou explicitement. Pour les <em>closures</em> le type est souvent implicite, aussi bien qu‚Äôon en oublie souvent qu‚Äôelles sont typ√©es. Le type d‚Äôune closure va √™tre d√©fini par ses param√®tres d‚Äôentr√©e et de sortie. Ainsi la <em>complexClosure</em>  ci-dessus est du type : <code>((String, Float)) -> (Bool)</code>.</p>\n<p>Je peux alors √©crire ce code puisque les closures sont du m√™me type :</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">let</span> otherComplexClosure = { (surname:<span class=\"hljs-type\">String</span>,size:<span class=\"hljs-type\">Float</span>) -> <span class=\"hljs-type\">Bool</span> <span class=\"hljs-keyword\">in</span>\n    <span class=\"hljs-comment\">// Other complexe Code</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n}\ncomplexClosure = otherComplexClosure</code></pre>\n<h3 id=\"utilisation-du-contexte\"><a href=\"#utilisation-du-contexte\" class=\"phenomic-HeadingAnchor\">#</a>Utilisation du contexte</h3>\n<p>Les <em>closures</em> ont une connaissance du contexte qui l‚Äôentoure. Ce qui veut dire que si la closure est cr√©√© dans une m√©thode, elle aura acc√®s :</p>\n<ul>\n<li>au contexte de classe en passant par <code>self</code> (variables, autre fonctions...)</li>\n<li>au contexte de la fonction (param√®tres, fonctions internes...)</li>\n</ul>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Animal</span> </span>{\n    <span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">\"Boby\"</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">crier</span><span class=\"hljs-params\">(cri:String)</span></span>{\n        <span class=\"hljs-keyword\">let</span> uselessClosure = {\n            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"<span class=\"hljs-subst\">\\(<span class=\"hljs-keyword\">self</span>.name)</span> cri <span class=\"hljs-subst\">\\(cri)</span>\"</span>)\n        }\n        uselessClosure()\n    }\n}</code></pre>\n<h3 id=\"trailing-closure\"><a href=\"#trailing-closure\" class=\"phenomic-HeadingAnchor\">#</a>Trailing Closure</h3>\n<p>Pour finir, un peu d'esth√©tisme car on aime tous le <em>beau</em> code. La <em>Trailing Closure</em> est une syntaxe d'appel de fonction qui permet de rendre le code plus facile √† lire.</p>\n<p>Prenant la fonction suivante, prenant une <code>URL</code> est une closure de type <code>Void->Void</code> :</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">doLongTask</span><span class=\"hljs-params\">(on file:URL,\n        completion:<span class=\"hljs-params\">()</span></span></span> -> ()){\n    <span class=\"hljs-comment\">//long task</span>\n    completion()\n}</code></pre>\n<p>On alors l'appeler cette fonction comme ceci :</p>\n<pre><code class=\"hljs language-swift\">doLongTask(on: aFileURL, completion:{\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Task Applied on <span class=\"hljs-subst\">\\(aFileURL)</span>\"</span>)\n})</code></pre>\n<p>Avec du code plus complexe, √ßa commence √† devenir difficile √† lire. Or si le dernier param√®tre d'une fonction est une <em>closure</em>, on peut alors √©crire l'appel comme ceci :</p>\n<pre><code class=\"hljs language-swift\">doLongTask(on: aFileURL){\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Task Applied on <span class=\"hljs-subst\">\\(aFileURL)</span>\"</span>)\n}</code></pre>\n<h2 id=\"pro-tip\"><a href=\"#pro-tip\" class=\"phenomic-HeadingAnchor\">#</a>Pro Tip</h2>\n<p>Imaginons une classe <code>A</code> ayant une variable <code>event</code>  et un classe <code>B</code> ayant une fonction <code>awesomeEvent</code> ayant le m√™me type que la variable <code>event</code> de la classe <code>A</code>. Je peux alors allouer, √† la variable <code>event</code>, le code de <code>awesomeEvent</code>.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span> </span>{\n    <span class=\"hljs-keyword\">var</span> event : ((<span class=\"hljs-type\">String</span>)-><span class=\"hljs-type\">Void</span>)?\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">awesome</span><span class=\"hljs-params\">(name:String)</span></span>{\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Awesome <span class=\"hljs-subst\">\\(name)</span>\"</span>)\n    }\n}\n\n<span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-type\">B</span>()\n<span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-type\">A</span>()\n\na.event = b.awesome\na.event?(<span class=\"hljs-string\">\"Mate\"</span>)</code></pre>\n<p><a href=\"http://swift.sandbox.bluemix.net/#/repl/59ecdb8508529b23242b5696\">Ex√©cutez ce code sur IBM Swift Sandbox c'est magique!</a></p>\n<h2 id=\"conclusion\"><a href=\"#conclusion\" class=\"phenomic-HeadingAnchor\">#</a>Conclusion</h2>\n<p>Voil√† vous savez tout, ou presque, sur les fonctions et les closures. Les closures ont vraiment la part belle en Swift, donc apprenez √† les utiliser et les comprendre pour simplifiez votre code. Elles sont partout dans les API iOS et macOS.</p>\n<p>Et un petit conseil: faite attention √† l'√©tat de vos <em>closures</em> dans vos <code>Thread</code> si vous ne voulez pas de fuite üòä</p>\n","rawBody":"\n**Swift** est un langage simple pour les d√©butants, tout en offrant de grandes possibilit√©es aux d√©veloppeurs exp√©riment√©s. Les *fonctions* Swift sont un bon exemple de cette fa√ßon d‚Äôavoir pens√© le langage.\n\n## Les fonctions\n\n### D√©claration simple\n\nLa d√©claration et l‚Äôutilisation de *fonctions* est simple. On commence avec le mot cl√© `func` suivi du *nom*, puis des *param√®tres* entre parenth√®ses (a.k.a. `input`) :\n\n```swift\nfunc sayHello(name:String, age:UInt){\n    print(\"Hello \\(name), you are \\(age)\")\n}\n```\n\nL‚Äôappel se fait aussi simplement que √ßa : `sayHello(name:\"Bob\", age: 32)`. Le mot cl√© `_` permet d'enlever le label du param√®tre dans l'appel si besoin :\n\n```swift\n// Declaration\nfunc sayHello(name:String,_ age:UInt){\n print(\"Hello \\(name), you are \\(age)\")\n}\n// Appel\nsayHello(name:\"Bob\", 32)\n```\n\nMais vous perdrez en clart√© de code suivant les cas. Par exemple, avec `min(3,6)` on voit tout de suite ce que fait la fonction. Alors que `sayHelloTo(\"Bob\", 32)`, le `32` pourrait √™tre beaucoup de choses.\n\n> Les param√®tres sont obligatoirement typ√©s, mais peuvent √™tre optionnels (en autorisant la valeur nil) avec la notation ? (e.g. Int?, String?).\n\nVous pouvez aussi d√©finir des valeurs par d√©fauts pour les param√®tres :\n\n```swift\n// Declaration\nfunc sayHello(name:String, _ age:UInt? = nil){\n    if age == nil {\n        print(\"Hello \\(name)\")\n    } else {\n        print(\"Hello \\(name), you are \\(age!)\") //! permet de pas afficher Optinal(value)\n    }\n}\n// Appel\nsayHello(name:\"Bob\") // -> Hello Bob\nsayHello(name:\"Bob\", 32) // ->  Hello Bob, you are 32\n```\n\nLa plupart du temps nos fonctions servent √† nous retourner des informations. Pour cela on utilise `->` en signe de retour suivi du type de la valeur retourn√©e.\n\n```\nfunc formatHelloSentence(name:String, age:UInt? = nil) -> String {\n    if age == nil {\n        return \"Hello \\(name)\"\n    } else {\n        return \"Hello \\(name), you are \\(age)\"\n    }\n}\n// Appel\nlet helloSentence = formatHelloSentence(name:\"Bob\", age: 32)\n```\n\n### Retours multiples ou Tuples\n\nApple n‚Äôest pas connu pour sa g√©n√©rosit√©, mais dans Swift ils en ont fait autrement `:troll:` : on peut retourner plusieurs valeurs avec une seule fonction. Pour cela on utilise un `Tuple` : un collection de variables ordonn√©es.\n\n```swift\nfunc hardFunction(fInputs:[Float])->(Int,Int,Float,String) {    \n    var a = 0\n    var b = 0\n    var f : Float = 0.0\n    var str = \"\"\n    //...\n    return (a,b,f,str)\n}\n```\n\nIci cette fonction prend en param√®tres un tableau de `Float` et retourne un *Tuple* compos√© de deux `Int`, un `Float` et un `String` dans cet ordre. Vous pouvez alors utiliser le *Tuple* comme une structure en utilisant l‚Äôindex des √©l√©ments du *Tuple* comme nom de variable (ex: `0`pour le premier `Int`, `3` pour le `String`).\n\n```swift\nlet myTuple = hardFunction([2.4,2.6,1.8])\nlet myTupleString = myTuple.3\n```\n\nMais ceci reste assez confus, alors on peut nommer les √©l√©ments.\n\n```swift\nfunc hardFunction(fInputs:[Float])->(valSup:Int,\n        valMax:Int,\n        average:Float,\n        errorString:String) {\n    //...\n}\n\n//utilisation\nlet myTuple = hardFunction([2.4,2.6,1.8])\nlet myTupleString = myTuple.errorString // myTuple.3 marche encore\n```\n\nL'ex√©cution du code permettant d'avoir les valeurs *Tuple* n'est effectu√©e qu'√† la demande de ces valeurs. Dans l'exemple ci-dessus, le code de `hardFunction` ne sera appel√© qu'√† la derni√®re ligne, car c'est l√† qu'on a besoin de `errorString`, pas avant.\n\n Et la notion de *Closure* fait son entr√©e!\n\n## La closure: la variable-fonction\n\n### Qu√©saco\n\n**Une *closure* est une partie de code, avec param√®tres et sorties, qui peut √™tre encapsul√© dans une variable, et ex√©cut√©e √† la demande**. Si vous d√©veloppez en C++ ou Objective-C vous connaissez peut-√™tre d√©j√† les *blocks* et en Java ou C# les *lambdas* qui sont des *features* tr√®s (tr√®s) proches.\n\n### D√©claration\n\nUne *closure*  se d√©clare gr√¢ce au `{}` et peut √™tre appel√©e (ex√©cut√©e) gr√¢ce aux parenth√®ses :\n\n```swift\n let helloClosure = {\n     print(\"hello, I‚Äôm a closure\")\n }\n\n helloClosure() // Le code est ex√©cut√© ici\n```\n\n√áa vous rappelle rien ? L‚Äôappel d‚Äôune *fonction* ! En r√©alit√©, la *fonction* est une *closure* particuli√®re associ√© √† un contexte (Object, environnement, Bundle...) pour r√©aliser des optimisations et une meilleur compr√©hension du code.\n\n> Pour une *closure* \"√† l‚Äôair libre\", on dit d‚Äôelle, qu‚Äôelle est *Self Contained* alors qu‚Äôune fonction est contenue par un contexte (`class` par exemple)\n\nComme les fonctions, les *closures*  ont des param√®tres d‚Äôentr√©e et de retour:  \n\n```swift\nlet complexClosure = {(name:String, age:Float) -> Bool in\n    // Code\n    return false\n}\nlet success = complexClosure(\"Louis\",32)\nprint(\"Louis has \\(success)\")\n```\n\nAinsi, les valeurs dans la premi√®re partie apr√®s la `{` sont les param√®tres d‚Äôentr√©es et apr√®s la `->` ce sont les param√®tres de sortie. Le code √† ex√©cuter est apr√®s le `in`.\n\n> Comme vous avez d√ª le remarquer, les *closures* n‚Äôont pas de param√®tres nominatif. IL faut passer les param√®tres d'entr√©e dans l'ordre de la d√©claration.\n\n### Closure et Type\n\nToute variable est typ√©e en *Swift*, implicitement ou explicitement. Pour les *closures* le type est souvent implicite, aussi bien qu‚Äôon en oublie souvent qu‚Äôelles sont typ√©es. Le type d‚Äôune closure va √™tre d√©fini par ses param√®tres d‚Äôentr√©e et de sortie. Ainsi la *complexClosure*  ci-dessus est du type : `((String, Float)) -> (Bool)`.\n\nJe peux alors √©crire ce code puisque les closures sont du m√™me type :\n\n```swift\nlet otherComplexClosure = { (surname:String,size:Float) -> Bool in\n    // Other complexe Code\n    return true\n}\ncomplexClosure = otherComplexClosure\n```\n\n### Utilisation du contexte\n\nLes *closures* ont une connaissance du contexte qui l‚Äôentoure. Ce qui veut dire que si la closure est cr√©√© dans une m√©thode, elle aura acc√®s :\n\n- au contexte de classe en passant par `self` (variables, autre fonctions...)\n- au contexte de la fonction (param√®tres, fonctions internes...)\n\n```swift\nclass Animal {\n    var name = \"Boby\"\n\n    func crier(cri:String){\n        let uselessClosure = {\n            print(\"\\(self.name) cri \\(cri)\")\n        }\n        uselessClosure()\n    }\n}\n```\n\n### Trailing Closure\n\nPour finir, un peu d'esth√©tisme car on aime tous le *beau* code. La *Trailing Closure* est une syntaxe d'appel de fonction qui permet de rendre le code plus facile √† lire.\n\nPrenant la fonction suivante, prenant une `URL` est une closure de type `Void->Void` :\n\n```swift\nfunc doLongTask(on file:URL,\n        completion:() -> ()){\n    //long task\n    completion()\n}\n```\n\nOn alors l'appeler cette fonction comme ceci :\n\n```swift\ndoLongTask(on: aFileURL, completion:{\n    print(\"Task Applied on \\(aFileURL)\")\n})\n```\n\nAvec du code plus complexe, √ßa commence √† devenir difficile √† lire. Or si le dernier param√®tre d'une fonction est une *closure*, on peut alors √©crire l'appel comme ceci :\n\n```swift\ndoLongTask(on: aFileURL){\n    print(\"Task Applied on \\(aFileURL)\")\n}\n```\n\n## Pro Tip\n\nImaginons une classe `A` ayant une variable `event`  et un classe `B` ayant une fonction `awesomeEvent` ayant le m√™me type que la variable `event` de la classe `A`. Je peux alors allouer, √† la variable `event`, le code de `awesomeEvent`.\n\n```swift\nclass A {\n    var event : ((String)->Void)?\n}\n\nclass B {\n    func awesome(name:String){\n        print(\"Awesome \\(name)\")\n    }\n}\n\nlet b = B()\nlet a = A()\n\na.event = b.awesome\na.event?(\"Mate\")\n```\n\n[Ex√©cutez ce code sur IBM Swift Sandbox c'est magique!](http://swift.sandbox.bluemix.net/#/repl/59ecdb8508529b23242b5696)\n\n## Conclusion\n\nVoil√† vous savez tout, ou presque, sur les fonctions et les closures. Les closures ont vraiment la part belle en Swift, donc apprenez √† les utiliser et les comprendre pour simplifiez votre code. Elles sont partout dans les API iOS et macOS.\n\nEt un petit conseil: faite attention √† l'√©tat de vos *closures* dans vos `Thread` si vous ne voulez pas de fuite üòä\n","__filename":"fr/articles/swift/closure/index.md","__url":"/fr/articles/swift/closure/","__resourceUrl":"/fr/articles/swift/closure/index.html","__dataUrl":"/fr/articles/swift/closure/index.html.38a5c3af80e04dfc9a08c9dcdd88a60d.json"}